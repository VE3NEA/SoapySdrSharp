//------------------------------------------------------------------------------
// <auto-generated />
//
// This file was automatically generated by SWIG (https://www.swig.org).
// Version 4.3.0
//
// Do not make changes to this file unless you know what you are doing - modify
// the SWIG interface file instead.
//------------------------------------------------------------------------------

namespace Pothosware.SoapySDR {

using System;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// Abstraction for an SDR transceiver device - configuration and streaming.
/// </summary>
public class Device : global::System.IDisposable {
  private global::System.Runtime.InteropServices.HandleRef swigCPtr;
  protected bool swigCMemOwn;

  internal Device(global::System.IntPtr cPtr, bool cMemoryOwn) {
    swigCMemOwn = cMemoryOwn;
    swigCPtr = new global::System.Runtime.InteropServices.HandleRef(this, cPtr);
  }

  internal static global::System.Runtime.InteropServices.HandleRef getCPtr(Device obj) {
    return (obj == null) ? new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero) : obj.swigCPtr;
  }

  internal static global::System.Runtime.InteropServices.HandleRef swigRelease(Device obj) {
    if (obj != null) {
      if (!obj.swigCMemOwn)
        throw new global::System.ApplicationException("Cannot release ownership as memory is not owned");
      global::System.Runtime.InteropServices.HandleRef ptr = obj.swigCPtr;
      obj.swigCMemOwn = false;
      obj.Dispose();
      return ptr;
    } else {
      return new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
    }
  }

  ~Device() {
    Dispose(false);
  }

  public void Dispose() {
    Dispose(true);
    global::System.GC.SuppressFinalize(this);
  }

  protected virtual void Dispose(bool disposing) {
    lock(this) {
      if (swigCPtr.Handle != global::System.IntPtr.Zero) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Unmake(this);
        }
        swigCPtr = new global::System.Runtime.InteropServices.HandleRef(null, global::System.IntPtr.Zero);
      }
    }
  }

    /// <summary>
    /// Enumerate a list of all available devices on the system.
    /// </summary>
    public static KwargsList Enumerate() => Enumerate("");

    /// <summary>
    /// Initialize a transmit stream given a list of channels and stream arguments.
    ///
    /// The implementation may change switches or power-up components.
    /// All stream API calls should be usable with the new stream object
    /// after setupStream() is complete, regardless of the activity state.
    ///
    /// The API allows any number of simultaneous TX and RX streams, but many dual-channel
    /// devices are limited to one stream in each direction, using either one or both channels.
    /// This call will throw an exception if an unsupported combination is requested,
    /// or if a requested channel in this direction is already in use by another stream.
    ///
    /// When multiple channels are added to a stream, they are typically expected to have
    /// the same sample rate. See SetSampleRate().
    /// </summary>
    ///
    /// <param name="format">The stream's sample type (see StreamFormat).</param>
    /// <param name="channels">A list of channels to use for the stream.</param>
    /// <param name="args">Stream arguments or empty for defaults.</param>
    /// <returns>
    /// A transmit stream created with the given settings.
    ///
    /// The returned stream is not required to have internal locking, and may not be used
    /// concurrently from multiple threads.
    /// </returns>
    public TxStream SetupTxStream(
        string format,
        uint[] channels,
        IDictionary<string, string> kwargs)
    {
        return new TxStream(this, format, channels, Utility.ToKwargs(kwargs));
    }

    /// <summary>
    /// Initialize a transmit stream given a list of channels and stream arguments.
    ///
    /// The implementation may change switches or power-up components.
    /// All stream API calls should be usable with the new stream object
    /// after setupStream() is complete, regardless of the activity state.
    ///
    /// The API allows any number of simultaneous TX and RX streams, but many dual-channel
    /// devices are limited to one stream in each direction, using either one or both channels.
    /// This call will throw an exception if an unsupported combination is requested,
    /// or if a requested channel in this direction is already in use by another stream.
    ///
    /// When multiple channels are added to a stream, they are typically expected to have
    /// the same sample rate. See SetSampleRate().
    /// </summary>
    ///
    /// <param name="format">The stream's sample type (see StreamFormat).</param>
    /// <param name="channels">A list of channels to use for the stream.</param>
    /// <param name="args">Stream arguments or empty for defaults (markup format: "keyA=valA, keyB=valB").</param>
    /// <returns>
    /// A transmit stream created with the given settings.
    ///
    /// The returned stream is not required to have internal locking, and may not be used
    /// concurrently from multiple threads.
    /// </returns>
    public TxStream SetupTxStream(
        string format,
        uint[] channels,
        string args) => SetupTxStream(format, channels, Utility.StringToKwargs(args));

    /// <summary>
    /// Initialize a receive stream given a list of channels and stream arguments.
    ///
    /// The implementation may change switches or power-up components.
    /// All stream API calls should be usable with the new stream object
    /// after setupStream() is complete, regardless of the activity state.
    ///
    /// The API allows any number of simultaneous TX and RX streams, but many dual-channel
    /// devices are limited to one stream in each direction, using either one or both channels.
    /// This call will throw an exception if an unsupported combination is requested,
    /// or if a requested channel in this direction is already in use by another stream.
    ///
    /// When multiple channels are added to a stream, they are typically expected to have
    /// the same sample rate. See SetSampleRate().
    /// </summary>
    ///
    /// <param name="format">The stream's sample type (see StreamFormat).</param>
    /// <param name="channels">A list of channels to use for the stream.</param>
    /// <param name="args">Stream arguments or empty for defaults.</param>
    /// <returns>
    /// A receive stream created with the given settings.
    ///
    /// The returned stream is not required to have internal locking, and may not be used
    /// concurrently from multiple threads.
    /// </returns>
    public RxStream SetupRxStream(
        string format,
        uint[] channels,
        IDictionary<string, string> kwargs)
    {
        return new RxStream(this, format, channels, Utility.ToKwargs(kwargs));
    }

    /// <summary>
    /// Initialize a receive stream given a list of channels and stream arguments.
    ///
    /// The implementation may change switches or power-up components.
    /// All stream API calls should be usable with the new stream object
    /// after setupStream() is complete, regardless of the activity state.
    ///
    /// The API allows any number of simultaneous TX and RX streams, but many dual-channel
    /// devices are limited to one stream in each direction, using either one or both channels.
    /// This call will throw an exception if an unsupported combination is requested,
    /// or if a requested channel in this direction is already in use by another stream.
    ///
    /// When multiple channels are added to a stream, they are typically expected to have
    /// the same sample rate. See SetSampleRate().
    /// </summary>
    ///
    /// <param name="format">The stream's sample type (see StreamFormat).</param>
    /// <param name="channels">A list of channels to use for the stream.</param>
    /// <param name="args">Stream arguments or empty for defaults (markup format: "keyA=valA, keyB=valB").</param>
    /// <returns>
    /// A receive stream created with the given settings.
    ///
    /// The returned stream is not required to have internal locking, and may not be used
    /// concurrently from multiple threads.
    /// </returns>
    public RxStream SetupRxStream(
        string format,
        uint[] channels,
        string args) => SetupRxStream(format, channels, Utility.StringToKwargs(args));

    /// <summary>
    /// Set the center frequency of the chain.
    ///  - For RX, this specifies the down-conversion frequency.
    ///  - For TX, this specifies the up-conversion frequency.
    ///
    /// When no args are provided, setFrequency() will tune the "RF"
    /// component as close as possible to the requested center frequency.
    /// Tuning inaccuracies will be compensated for with the "BB" component.
    ///
    /// The args can be used to augment the tuning algorithm.
    ///  - Use "OFFSET" to specify an "RF" tuning offset,
    ///    usually with the intention of moving the LO out of the passband.
    ///    The offset will be compensated for using the "BB" component.
    ///  - Use the name of a component for the key and a frequency in Hz
    ///    as the value (any format) to enforce a specific frequency.
    ///    The other components will be tuned with compensation
    ///    to achieve the specified overall frequency.
    ///  - Use the name of a component for the key and the value "IGNORE"
    ///    so that the tuning algorithm will avoid altering the component.
    ///  - Vendor specific implementations can also use the same args to augment
    ///    tuning in other ways such as specifying fractional vs integer N tuning.
    /// </summary>
    /// <param name="direction">The channel direction (RX or TX)</param>
    /// <param name="channel">An available channel on the device</param>
    /// <param name="frequency">The center frequency in Hz</param>
    /// <param name="args">Optional tuner arguments</param>
    public void SetFrequency(Direction direction, uint channel, double frequency, string args = "") =>
        SetFrequency(direction, channel, frequency, Utility.StringToKwargs(args));

    /// <summary>
    /// Tune the center frequency of the specified element.
    ///  - For RX, this specifies the down-conversion frequency.
    ///  - For TX, this specifies the up-conversion frequency.
    ///
    /// When no args are provided, setFrequency() will tune the "RF"
    /// component as close as possible to the requested center frequency.
    /// Tuning inaccuracies will be compensated for with the "BB" component.
    ///
    /// The args can be used to augment the tuning algorithm.
    ///  - Use "OFFSET" to specify an "RF" tuning offset,
    ///    usually with the intention of moving the LO out of the passband.
    ///    The offset will be compensated for using the "BB" component.
    ///  - Use the name of a component for the key and a frequency in Hz
    ///    as the value (any format) to enforce a specific frequency.
    ///    The other components will be tuned with compensation
    ///    to achieve the specified overall frequency.
    ///  - Use the name of a component for the key and the value "IGNORE"
    ///    so that the tuning algorithm will avoid altering the component.
    ///  - Vendor specific implementations can also use the same args to augment
    ///    tuning in other ways such as specifying fractional vs integer N tuning.
    /// </summary>
    /// <param name="direction">The channel direction (RX or TX)</param>
    /// <param name="channel">An available channel on the device</param>
    /// <param name="name">The name of a tunable element</param>
    /// <param name="frequency">The center frequency in Hz</param>
    /// <param name="args">Optional tuner arguments</param>
    public void SetFrequency(Direction direction, uint channel, string name, double frequency, string args = "") =>
        SetFrequency(direction, channel, name, frequency, Utility.StringToKwargs(args));

    /// <summary>
    /// Readback a global sensor given the name, typecasted to the given type.
    /// </summary>
    /// <typeparam name="T">The type to cast the sensor value</typeparam>
    /// <param name="key">The ID name of an available sensor</param>
    /// <returns>The current value of the sensor</returns>
    public T ReadSensor<T>(string key)
    {
        return (T)(new SoapyConvertible(ReadSensor(key)).ToType(typeof(T), null));
    }

    /// <summary>
    /// Readback a channel sensor given the name, typecasted to the given type.
    /// </summary>
    /// <typeparam name="T">The type to cast the sensor value</typeparam>
    /// <param name="direction">The channel direction (RX or TX)</param>
    /// <param name="channel">An available channel on the device</param>
    /// <param name="key">The ID name of an available sensor</param>
    /// <returns>The current value of the sensor</returns>
    public T ReadSensor<T>(Direction direction, uint channel, string key)
    {
        return (T)(new SoapyConvertible(ReadSensor(direction, channel, key)).ToType(typeof(T), null));
    }

    /// <summary>
    /// Read an arbitrary setting on the device, typecasted to the given type.
    ///
    /// This function will throw if T is not a string, bool, or numeric primitive.
    /// </summary>
    /// <typeparam name="T">The type to cast the setting</typeparam>
    /// <param name="key">The setting identifier</param>
    /// <returns>The setting value</returns>
    public T ReadSetting<T>(string key)
    {
        return (T)(new SoapyConvertible(ReadSetting(key)).ToType(typeof(T), null));
    }

    /// <summary>
    /// Read an arbitrary channel setting on the device, typecasted to the given type.
    ///
    /// This function will throw if T is not a string, bool, or numeric primitive.
    /// </summary>
    /// <typeparam name="T">The type to cast the setting</typeparam>
    /// <param name="direction">The channel direction (RX or TX)</param>
    /// <param name="channel">An available channel on the device</param>
    /// <param name="key">The setting identifier</param>
    /// <returns>The setting value</returns>
    public T ReadSetting<T>(Direction direction, uint channel, string key)
    {
        return (T)(new SoapyConvertible(ReadSetting(direction, channel, key)).ToType(typeof(T), null));
    }

    /// <summary>
    /// Write an arbitrary setting on the device, typecasted from the given type.
    ///
    /// For bools and primitive numeric types, SoapySDR's internal type conversion is used.
    /// Otherwise, the value of the input's ToString() will be passed in.
    /// </summary>
    /// <typeparam name="T">The type to cast the setting</typeparam>
    /// <param name="key">The setting identifier</param>
    /// <param name="value">The setting value</param>
    public void WriteSetting<T>(string key, T value)
    {
        WriteSetting(key, new SoapyConvertible(value).ToString());
    }

    /// <summary>
    /// Write an arbitrary channel setting on the device, typecasted from the given type.
    ///
    /// For bools and primitive numeric types, SoapySDR's internal type conversion is used.
    /// Otherwise, the value of the input's ToString() will be passed in.
    /// </summary>
    /// <typeparam name="T">The type to cast the setting</typeparam>
    /// <param name="direction">The channel direction (RX or TX)</param>
    /// <param name="channel">An available channel on the device</param>
    /// <param name="key">The setting identifier</param>
    /// <param name="value">The setting value</param>
    public void WriteSetting<T>(Direction direction, uint channel, string key, T value)
    {
        WriteSetting(direction, channel, key, new SoapyConvertible(value).ToString());
    }

    //
    // Object overrides
    //

    public override string ToString() => string.Format("{0}:{1}", DriverKey, HardwareKey);

    public override bool Equals(object obj) => (obj as Device)?.swigCPtr.Equals(swigCPtr) ?? false;

    public override int GetHashCode() => HashCodeBuilder.Create()
        .AddValue(GetType())
        .AddValue(swigCPtr);

  
/// <summary>
/// Enumerate a list of devices on the system, given a set of filters.
/// </summary>
/// <param name="args">A map of construction key/value argument filters</param>
/// <returns>A list of argument maps, each unique to a device</returns>
public static KwargsList Enumerate(System.Collections.Generic.IDictionary<string, string> args) {

        Kwargs tempargs = Utility.ToKwargs(args);
    
    {
      KwargsList ret = new KwargsList(SoapySDRPINVOKE.Device_Enumerate__SWIG_0(Kwargs.getCPtr(tempargs)), true);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Enumerate a list of devices on the system, given a set of filters.
///
/// Markup format for args: "keyA=valA, keyB=valB".
/// </summary>
/// <param name="args">A markup string of device construction key/value argument filters</param>
/// <returns>A list of argument maps, each unique to a device</returns>
public static KwargsList Enumerate(string args) {
    KwargsList ret = new KwargsList(SoapySDRPINVOKE.Device_Enumerate__SWIG_1(args), true);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  private static void Unmake(Device device) {
    SoapySDRPINVOKE.Device_Unmake(Device.getCPtr(device));
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
  }

  
/// <summary>
/// Set the frontend mapping of available DSP units to RF frontends.
///
/// This mapping controls channel mapping and channel availability.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="mapping">A vendor-specific mapping string</param>
public void SetFrontendMapping(Direction direction, string mapping) {
int tempdirection = (int)direction;
    {
      SoapySDRPINVOKE.Device_SetFrontendMapping(swigCPtr, tempdirection, mapping);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    }
  }

  
/// <summary>
/// Get the mapping configuration string.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <returns>A vendor-specific mapping string</returns>
public string GetFrontendMapping(Direction direction) {
int tempdirection = (int)direction;
    {
      string ret = SoapySDRPINVOKE.Device_GetFrontendMapping(swigCPtr, tempdirection);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Get the number of channels given the streaming direction.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
public uint GetNumChannels(Direction direction) {
int tempdirection = (int)direction;
    {
      uint ret = SoapySDRPINVOKE.Device_GetNumChannels(swigCPtr, tempdirection);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Query a dictionary of available channel information.
///
/// This dictionary can any number of values like
/// decoder type, version, available functions...
/// This information can be displayed to the user
/// to help identify the instantiated channel.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
public Kwargs GetChannelInfo(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      Kwargs ret = new Kwargs(SoapySDRPINVOKE.Device_GetChannelInfo(swigCPtr, tempdirection, channel), true);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Find out if the specified channel is half or full duplex.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>True for full duplex, false for half duplex</returns>
public bool GetFullDuplex(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      bool ret = SoapySDRPINVOKE.Device_GetFullDuplex(swigCPtr, tempdirection, channel);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Query a list of the available stream formats.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>A list of allowed format strings. See Pothosware.SoapySDR.StreamFormat.</returns>
public StringList GetStreamFormats(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      StringList ret = new StringList(SoapySDRPINVOKE.Device_GetStreamFormats(swigCPtr, tempdirection, channel), true);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Get the hardware's native stream format for this channel.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <param name="fullScale">The maximum possible value (output)</param>
/// <returns>The native stream format string. See Pothosware.SoapySDR.StreamFormat.</returns>
public string GetNativeStreamFormat(Direction direction, uint channel, out double fullScale) {
int tempdirection = (int)direction;
    {
      string ret = SoapySDRPINVOKE.Device_GetNativeStreamFormat(swigCPtr, tempdirection, channel, out fullScale);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Query the argument info description for stream args.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
public ArgInfoList GetStreamArgsInfo(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      ArgInfoList ret = new ArgInfoList(SoapySDRPINVOKE.Device_GetStreamArgsInfo(swigCPtr, tempdirection, channel), true);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Get a list of available antennas to select on a given chain.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>A list of available antenna names</returns>
public StringList ListAntennas(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      StringList ret = new StringList(SoapySDRPINVOKE.Device_ListAntennas(swigCPtr, tempdirection, channel), true);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Set the selected antenna on a chain.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <param name="name">The name of an available antenna</param>
public void SetAntenna(Direction direction, uint channel, string name) {
int tempdirection = (int)direction;
    {
      SoapySDRPINVOKE.Device_SetAntenna(swigCPtr, tempdirection, channel, name);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    }
  }

  
/// <summary>
/// Set the selected antenna on a chain.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>The name of an available antenna</returns>
public string GetAntenna(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      string ret = SoapySDRPINVOKE.Device_GetAntenna(swigCPtr, tempdirection, channel);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Does the device support automatic frontend DC offset correction?
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>True if automatic correction is supported</returns>
public bool HasDCOffsetMode(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      bool ret = SoapySDRPINVOKE.Device_HasDCOffsetMode(swigCPtr, tempdirection, channel);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Enable or disable automatic frontend DC offset correction.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <param name="automatic">True to enable correction, false to disable</param>
public void SetDCOffsetMode(Direction direction, uint channel, bool automatic) {
int tempdirection = (int)direction;
    {
      SoapySDRPINVOKE.Device_SetDCOffsetMode(swigCPtr, tempdirection, channel, automatic);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    }
  }

  
/// <summary>
/// Is automatic frontend DC offset correction enabled?
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>True if correction is enabled, false if disabled</returns>
public bool GetDCOffsetMode(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      bool ret = SoapySDRPINVOKE.Device_GetDCOffsetMode(swigCPtr, tempdirection, channel);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Does the device support frontend DC offset correction?
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>True if correction is supported</returns>
public bool HasDCOffset(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      bool ret = SoapySDRPINVOKE.Device_HasDCOffset(swigCPtr, tempdirection, channel);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Set the frontend DC offset correction.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <param name="offset">The relative correction (1.0 max)</param>
public void SetDCOffset(Direction direction, uint channel, System.Numerics.Complex offset) {
int tempdirection = (int)direction;
    {
      SoapySDRPINVOKE.Device_SetDCOffset(swigCPtr, tempdirection, channel, offset);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    }
  }

  
/// <summary>
/// Get the frontend DC offset correction.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>The relative correction (1.0 max)</returns>
public System.Numerics.Complex GetDCOffset(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      System.Numerics.Complex ret = SoapySDRPINVOKE.Device_GetDCOffset(swigCPtr, tempdirection, channel);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Does the device support frontend IQ balance correction?
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>True if correction is supported</returns>
public bool HasIQBalance(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      bool ret = SoapySDRPINVOKE.Device_HasIQBalance(swigCPtr, tempdirection, channel);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Set the frontend IQ balance correction.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <param name="balance">The relative correction (1.0 max)</param>
public void SetIQBalance(Direction direction, uint channel, System.Numerics.Complex balance) {
int tempdirection = (int)direction;
    {
      SoapySDRPINVOKE.Device_SetIQBalance(swigCPtr, tempdirection, channel, balance);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    }
  }

  
/// <summary>
/// Get the frontend IQ balance correction.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>The relative correction (1.0 max)</returns>
public System.Numerics.Complex GetIQBalance(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      System.Numerics.Complex ret = SoapySDRPINVOKE.Device_GetIQBalance(swigCPtr, tempdirection, channel);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Does the device support automatic frontend IQ balance correction?
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>True if automatic correction is supported</returns>
public bool HasIQBalanceMode(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      bool ret = SoapySDRPINVOKE.Device_HasIQBalanceMode(swigCPtr, tempdirection, channel);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Enable or disable automatic frontend IQ balance correction.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <param name="automatic">True to enable correction, false to disable</param>
public void SetIQBalanceMode(Direction direction, uint channel, bool automatic) {
int tempdirection = (int)direction;
    {
      SoapySDRPINVOKE.Device_SetIQBalanceMode(swigCPtr, tempdirection, channel, automatic);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    }
  }

  
/// <summary>
/// Is automatic frontend IQ balance correction enabled?
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>True if correction is enabled, false if disabled</returns>
public bool GetIQBalanceMode(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      bool ret = SoapySDRPINVOKE.Device_GetIQBalanceMode(swigCPtr, tempdirection, channel);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Does the device support frontend frequency correction?
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>True if correction is supported</returns>
public bool HasFrequencyCorrection(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      bool ret = SoapySDRPINVOKE.Device_HasFrequencyCorrection(swigCPtr, tempdirection, channel);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Set the frontend frequency correction.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <param name="value">The correction in PPM</param>
public void SetFrequencyCorrection(Direction direction, uint channel, double value) {
int tempdirection = (int)direction;
    {
      SoapySDRPINVOKE.Device_SetFrequencyCorrection(swigCPtr, tempdirection, channel, value);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    }
  }

  
/// <summary>
/// Get the frontend frequency correction.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>The correction in PPM</returns>
public double GetFrequencyCorrection(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      double ret = SoapySDRPINVOKE.Device_GetFrequencyCorrection(swigCPtr, tempdirection, channel);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// List available amplification elements, ordered from RF to baseband.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>A list of gain string names</returns>
public StringList ListGains(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      StringList ret = new StringList(SoapySDRPINVOKE.Device_ListGains(swigCPtr, tempdirection, channel), true);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Does the device support automatic gain control?
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>True if automatic correction is supported</returns>
public bool HasGainMode(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      bool ret = SoapySDRPINVOKE.Device_HasGainMode(swigCPtr, tempdirection, channel);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Enable or disable automatic gain control on the chain.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <param name="automatic">True to enable automatic gain control, false to disable</param>
public void SetGainMode(Direction direction, uint channel, bool automatic) {
int tempdirection = (int)direction;
    {
      SoapySDRPINVOKE.Device_SetGainMode(swigCPtr, tempdirection, channel, automatic);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    }
  }

  
/// <summary>
/// Is automatic gain control enabled on the chain?
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>True if automatic gain control is enabled, false if disabled</returns>
public bool GetGainMode(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      bool ret = SoapySDRPINVOKE.Device_GetGainMode(swigCPtr, tempdirection, channel);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Set the overall amplification in a chain.
///
/// The gain will be distributed automatically across available elements.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <param name="value">The new amplification value in dB</param>
public void SetGain(Direction direction, uint channel, double value) {
int tempdirection = (int)direction;
    {
      SoapySDRPINVOKE.Device_SetGain__SWIG_0(swigCPtr, tempdirection, channel, value);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    }
  }

  
/// <summary>
/// Set the value of an amplification element in a chain.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <param name="name">The name of an amplification element</param>
/// <param name="value">The new amplification value in dB</param>
public void SetGain(Direction direction, uint channel, string name, double value) {
int tempdirection = (int)direction;
    {
      SoapySDRPINVOKE.Device_SetGain__SWIG_1(swigCPtr, tempdirection, channel, name, value);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    }
  }

  
/// <summary>
/// Get the overall value of the gain elements in a chain.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>The value of the gain in dB</returns>
public double GetGain(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      double ret = SoapySDRPINVOKE.Device_GetGain__SWIG_0(swigCPtr, tempdirection, channel);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Get the value of an individual amplification element in a chain.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <param name="name">The name of an amplification element</param>
/// <returns>The value of the gain in dB</returns>
public double GetGain(Direction direction, uint channel, string name) {
int tempdirection = (int)direction;
    {
      double ret = SoapySDRPINVOKE.Device_GetGain__SWIG_1(swigCPtr, tempdirection, channel, name);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Get the overall range of possible gain values.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>A list of gain ranges in dB</returns>
public Range GetGainRange(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      Range ret = new Range(SoapySDRPINVOKE.Device_GetGainRange__SWIG_0(swigCPtr, tempdirection, channel), true);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Get the range of possible gain values for a specific element.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <param name="name">The name of an amplification element</param>
/// <returns>A list of gain ranges in dB</returns>
public Range GetGainRange(Direction direction, uint channel, string name) {
int tempdirection = (int)direction;
    {
      Range ret = new Range(SoapySDRPINVOKE.Device_GetGainRange__SWIG_1(swigCPtr, tempdirection, channel, name), true);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Set the center frequency of the chain.
///  - For RX, this specifies the down-conversion frequency.
///  - For TX, this specifies the up-conversion frequency.
///
/// When no args are provided, setFrequency() will tune the "RF"
/// component as close as possible to the requested center frequency.
/// Tuning inaccuracies will be compensated for with the "BB" component.
///
/// The args can be used to augment the tuning algorithm.
///  - Use "OFFSET" to specify an "RF" tuning offset,
///    usually with the intention of moving the LO out of the passband.
///    The offset will be compensated for using the "BB" component.
///  - Use the name of a component for the key and a frequency in Hz
///    as the value (any format) to enforce a specific frequency.
///    The other components will be tuned with compensation
///    to achieve the specified overall frequency.
///  - Use the name of a component for the key and the value "IGNORE"
///    so that the tuning algorithm will avoid altering the component.
///  - Vendor specific implementations can also use the same args to augment
///    tuning in other ways such as specifying fractional vs integer N tuning.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <param name="frequency">The center frequency in Hz</param>
/// <param name="args">Optional tuner arguments</param>
public void SetFrequency(Direction direction, uint channel, double frequency, System.Collections.Generic.IDictionary<string, string> args) {
int tempdirection = (int)direction;

        Kwargs tempargs = Utility.ToKwargs(args);
    
    {
      SoapySDRPINVOKE.Device_SetFrequency__SWIG_0(swigCPtr, tempdirection, channel, frequency, Kwargs.getCPtr(tempargs));
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    }
  }

  
/// <summary>
/// Tune the center frequency of the specified element.
///  - For RX, this specifies the down-conversion frequency.
///  - For TX, this specifies the up-conversion frequency.
///
/// When no args are provided, setFrequency() will tune the "RF"
/// component as close as possible to the requested center frequency.
/// Tuning inaccuracies will be compensated for with the "BB" component.
///
/// The args can be used to augment the tuning algorithm.
///  - Use "OFFSET" to specify an "RF" tuning offset,
///    usually with the intention of moving the LO out of the passband.
///    The offset will be compensated for using the "BB" component.
///  - Use the name of a component for the key and a frequency in Hz
///    as the value (any format) to enforce a specific frequency.
///    The other components will be tuned with compensation
///    to achieve the specified overall frequency.
///  - Use the name of a component for the key and the value "IGNORE"
///    so that the tuning algorithm will avoid altering the component.
///  - Vendor specific implementations can also use the same args to augment
///    tuning in other ways such as specifying fractional vs integer N tuning.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <param name="name">The name of a tunable element</param>
/// <param name="frequency">The center frequency in Hz</param>
/// <param name="args">Optional tuner arguments</param>
public void SetFrequency(Direction direction, uint channel, string name, double frequency, System.Collections.Generic.IDictionary<string, string> args) {
int tempdirection = (int)direction;

        Kwargs tempargs = Utility.ToKwargs(args);
    
    {
      SoapySDRPINVOKE.Device_SetFrequency__SWIG_1(swigCPtr, tempdirection, channel, name, frequency, Kwargs.getCPtr(tempargs));
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    }
  }

  
/// <summary>
/// Get the overall center frequency of the chain.
///  - For RX, this specifies the down-conversion frequency.
///  - For TX, this specifies the up-conversion frequency.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>The center frequency in Hz</returns>
public double GetFrequency(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      double ret = SoapySDRPINVOKE.Device_GetFrequency__SWIG_0(swigCPtr, tempdirection, channel);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Get the center frequency in a tunable element of the chain.
///  - For RX, this specifies the down-conversion frequency.
///  - For TX, this specifies the up-conversion frequency.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <param name="name">The name of a tunable element</param>
/// <returns>The center frequency in Hz</returns>
public double GetFrequency(Direction direction, uint channel, string name) {
int tempdirection = (int)direction;
    {
      double ret = SoapySDRPINVOKE.Device_GetFrequency__SWIG_1(swigCPtr, tempdirection, channel, name);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// List available tunable elements in the chain, ordered from RF to baseband.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>A list of tunable elements by name</returns>
public StringList ListFrequencies(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      StringList ret = new StringList(SoapySDRPINVOKE.Device_ListFrequencies(swigCPtr, tempdirection, channel), true);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Get the range of overall frequency values.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>A list of frequency ranges in Hz</returns>
public RangeList GetFrequencyRange(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      RangeList ret = new RangeList(SoapySDRPINVOKE.Device_GetFrequencyRange__SWIG_0(swigCPtr, tempdirection, channel), true);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Get the range of tunable values for the specified element.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <param name="name">The name of a tunable elements</param>
/// <returns>A list of frequency ranges in Hz</returns>
public RangeList GetFrequencyRange(Direction direction, uint channel, string name) {
int tempdirection = (int)direction;
    {
      RangeList ret = new RangeList(SoapySDRPINVOKE.Device_GetFrequencyRange__SWIG_1(swigCPtr, tempdirection, channel, name), true);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Query the argument info description for tune args.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>A list of argument info structs</returns>
public ArgInfoList GetFrequencyArgsInfo(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      ArgInfoList ret = new ArgInfoList(SoapySDRPINVOKE.Device_GetFrequencyArgsInfo(swigCPtr, tempdirection, channel), true);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Set the baseband sample rate of the chain.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <param name="rate">The rate in samples per second</param>
public void SetSampleRate(Direction direction, uint channel, double rate) {
int tempdirection = (int)direction;
    {
      SoapySDRPINVOKE.Device_SetSampleRate(swigCPtr, tempdirection, channel, rate);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    }
  }

  
/// <summary>
/// Get the baseband sample rate of the chain.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>The rate in samples per second</returns>
public double GetSampleRate(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      double ret = SoapySDRPINVOKE.Device_GetSampleRate(swigCPtr, tempdirection, channel);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Get the range of possible baseband sample rates.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>A list of sample rates in samples per second</returns>
public RangeList GetSampleRateRange(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      RangeList ret = new RangeList(SoapySDRPINVOKE.Device_GetSampleRateRange(swigCPtr, tempdirection, channel), true);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Set the baseband filter width of the chain.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <param name="bw">The baseband filter width in Hz</param>
public void SetBandwidth(Direction direction, uint channel, double bw) {
int tempdirection = (int)direction;
    {
      SoapySDRPINVOKE.Device_SetBandwidth(swigCPtr, tempdirection, channel, bw);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    }
  }

  
/// <summary>
/// Get the baseband filter width of the chain.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>The baseband filter width in Hz</returns>
public double GetBandwidth(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      double ret = SoapySDRPINVOKE.Device_GetBandwidth(swigCPtr, tempdirection, channel);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Get the range of possible baseband filter widths.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>A list of bandwidth ranges in Hz</returns>
public RangeList GetBandwidthRange(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      RangeList ret = new RangeList(SoapySDRPINVOKE.Device_GetBandwidthRange(swigCPtr, tempdirection, channel), true);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Does this device have a hardware clock?
/// </summary>
/// <param name="what">An optional clock name</param>
/// <returns>True if the hardware clock exists</returns>
public bool HasHardwareTime(string what) {
    bool ret = SoapySDRPINVOKE.Device_HasHardwareTime(swigCPtr, what);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  
/// <summary>
/// Read the time from the hardware clock on the device.
/// </summary>
/// <param name="what">An optional name of a specific time counter</param>
/// <returns>The time in nanoseconds</returns>
public long GetHardwareTime(string what) {
    long ret = SoapySDRPINVOKE.Device_GetHardwareTime(swigCPtr, what);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  
/// <summary>
/// Write the time to the hardware clock on the device.
/// </summary>
/// <param name="timeNs">The time in nanoseconds</param>
/// <param name="what">Name of a specific time counter</param>
public void SetHardwareTime(long timeNs, string what) {
    SoapySDRPINVOKE.Device_SetHardwareTime__SWIG_0(swigCPtr, timeNs, what);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
  }

  
/// <summary>
/// Write the time to the hardware clock on the device.
/// </summary>
/// <param name="timeNs">The time in nanoseconds</param>
public void SetHardwareTime(long timeNs) {
    SoapySDRPINVOKE.Device_SetHardwareTime__SWIG_1(swigCPtr, timeNs);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
  }

  
/// <summary>
/// List the available global readback sensors.
///
/// A sensor can represent a reference lock, RSSI, temperature.
/// </summary>
/// <returns>A list of available sensor string names</returns>
public StringList ListSensors() {
    StringList ret = new StringList(SoapySDRPINVOKE.Device_ListSensors__SWIG_0(swigCPtr), true);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  
/// <summary>
/// Get meta-information about a global sensor.
///
/// Example: displayable name, type, range.
/// </summary>
/// <returns>Meta-information about a sensor</returns>
public ArgInfo GetSensorInfo(string key) {
    ArgInfo ret = new ArgInfo(SoapySDRPINVOKE.Device_GetSensorInfo__SWIG_0(swigCPtr, key), true);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  
/// <summary>
/// Readback a global sensor given the name.
///
/// The value returned is a string which can represent
/// a boolean ("true"/"false"), an integer, or float.
/// <param name="key">The ID name of an available sensor</param>
/// <returns>The current value of the sensor</returns>
public string ReadSensor(string key) {
    string ret = SoapySDRPINVOKE.Device_ReadSensor__SWIG_0(swigCPtr, key);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  
/// <summary>
/// List the available channel readback sensors.
///
/// A sensor can represent a reference lock, RSSI, temperature.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>A list of available sensor string names</returns>
public StringList ListSensors(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      StringList ret = new StringList(SoapySDRPINVOKE.Device_ListSensors__SWIG_1(swigCPtr, tempdirection, channel), true);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Get meta-information about a channel sensor.
///
/// Example: displayable name, type, range.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <returns>Meta-information about a sensor</returns>
public ArgInfo GetSensorInfo(Direction direction, uint channel, string key) {
int tempdirection = (int)direction;
    {
      ArgInfo ret = new ArgInfo(SoapySDRPINVOKE.Device_GetSensorInfo__SWIG_1(swigCPtr, tempdirection, channel, key), true);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Readback a channel sensor given the name.
///
/// The value returned is a string which can represent
/// a boolean ("true"/"false"), an integer, or float.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <param name="key">The ID name of an available sensor</param>
/// <returns>The current value of the sensor</param>
public string ReadSensor(Direction direction, uint channel, string key) {
int tempdirection = (int)direction;
    {
      string ret = SoapySDRPINVOKE.Device_ReadSensor__SWIG_1(swigCPtr, tempdirection, channel, key);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Write a register on the device given the interface name.
///
/// This can represent a register on a soft CPU, FPGA, IC;
/// the interpretation is up the implementation to decide.
/// </summary>
/// <param name="name">The name of a available register interface</param>
/// <param name="addr"The register address</param>
/// <param name="value">The register value</param>
public void WriteRegister(string name, uint addr, uint value) {
    SoapySDRPINVOKE.Device_WriteRegister(swigCPtr, name, addr, value);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
  }

  
/// <summary>
/// Read a register on the device given the interface name.
/// </summary>
/// <param name="name">The name of a available register interface</param>
/// <param name="addr">The register address</param>
/// <returns>The register value</returns>
public uint ReadRegister(string name, uint addr) {
    uint ret = SoapySDRPINVOKE.Device_ReadRegister(swigCPtr, name, addr);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  public virtual void WriteRegisters(string name, uint addr, uint[] value) {

        var tempvalue = new UnsignedListInternal(value);
    
    {
      SoapySDRPINVOKE.Device_WriteRegisters(swigCPtr, name, addr, UnsignedListInternal.getCPtr(tempvalue));
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    }
  }

  public virtual uint[] ReadRegisters(string name, uint addr, uint length) {
    var unsignedListPtr = SoapySDRPINVOKE.Device_ReadRegisters(swigCPtr, name, addr, length);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();

    return new UnsignedListInternal(unsignedListPtr, false).ToArray();
}

  
/// <summary>Describe the allowed keys and values used for settings.</summary>
/// <returns>A list of argument info structures</returns>
public ArgInfoList GetSettingInfo() {
    ArgInfoList ret = new ArgInfoList(SoapySDRPINVOKE.Device_GetSettingInfo__SWIG_0(swigCPtr), true);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  
/// <summary>Get information on a specific setting.</summary>
/// <param name="key">The setting identifier</param>
/// <returns>All information for a specific setting</returns>
public ArgInfo GetSettingInfo(string key) {
    ArgInfo ret = new ArgInfo(SoapySDRPINVOKE.Device_GetSettingInfo__SWIG_1(swigCPtr, key), true);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  
/// <summary>
/// Write an arbitrary setting on the device.
///
/// The interpretation is up the implementation.
/// </summary>
/// <param name="key">The setting identifier</param>
/// <param name="value">The setting value</param>
public void WriteSetting(string key, string value) {
    SoapySDRPINVOKE.Device_WriteSetting__SWIG_0(swigCPtr, key, value);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
  }

  
/// <summary>Read an arbitrary setting on the device.</summary>
/// <param name="key">The setting identifier</param>
/// <returns>The setting value</returns>
public string ReadSetting(string key) {
    string ret = SoapySDRPINVOKE.Device_ReadSetting__SWIG_0(swigCPtr, key);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  
/// <summary>Describe the allowed keys and values used for channel settings.</summary>
/// <param name="direction">The channel direction (RX or TX)</summary></param>
/// <param name="channel">An available channel on the device</param>
/// <returns>A list of argument info structures</returns>
public ArgInfoList GetSettingInfo(Direction direction, uint channel) {
int tempdirection = (int)direction;
    {
      ArgInfoList ret = new ArgInfoList(SoapySDRPINVOKE.Device_GetSettingInfo__SWIG_2(swigCPtr, tempdirection, channel), true);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>Get information on a specific channel setting.</summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <param name="key">The setting identifier</param>
/// <returns>All information for a specific channel setting</returns>
public ArgInfo GetSettingInfo(Direction direction, uint channnel, string key) {
int tempdirection = (int)direction;
    {
      ArgInfo ret = new ArgInfo(SoapySDRPINVOKE.Device_GetSettingInfo__SWIG_3(swigCPtr, tempdirection, channnel, key), true);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>
/// Write an arbitrary channel setting on the device.
///
/// The interpretation is up the implementation.
/// </summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <param name="key">The setting identifier</param>
/// <param name="value">The setting value</param>
public void WriteSetting(Direction direction, uint channel, string key, string value) {
int tempdirection = (int)direction;
    {
      SoapySDRPINVOKE.Device_WriteSetting__SWIG_1(swigCPtr, tempdirection, channel, key, value);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    }
  }

  
/// <summary>Read an arbitrary channel setting on the device.</summary>
/// <param name="direction">The channel direction (RX or TX)</param>
/// <param name="channel">An available channel on the device</param>
/// <param name="key">The setting identifier</param>
/// <returns>The setting value</returns>
public string ReadSetting(Direction direction, uint channel, string key) {
int tempdirection = (int)direction;
    {
      string ret = SoapySDRPINVOKE.Device_ReadSetting__SWIG_1(swigCPtr, tempdirection, channel, key);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  
/// <summary>Write the value of a GPIO bank.</summary>
/// <param name="bank">The name of an available bank</param>
/// <param name="value">An integer representing GPIO bits</param>
public void WriteGPIO(string bank, uint value) {
    SoapySDRPINVOKE.Device_WriteGPIO__SWIG_0(swigCPtr, bank, value);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
  }

  
/// <summary>Write the value of a GPIO bank with a modification mask.</summary>
/// <param name="bank">The name of an available bank</param>
/// <param name="value">An integer representing GPIO bits</param>
/// <param name="mask">A modification mask where 1 = modify</param>
public void WriteGPIO(string bank, uint value, uint mask) {
    SoapySDRPINVOKE.Device_WriteGPIO__SWIG_1(swigCPtr, bank, value, mask);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
  }

  
/// <summary>Readback the value of a GPIO bank.</summary>
/// <param name="bank">The name of an available bank</param>
/// <returns>An integer representing GPIO bits</returns>
public uint ReadGPIO(string bank) {
    uint ret = SoapySDRPINVOKE.Device_ReadGPIO(swigCPtr, bank);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  
/// <summary>
/// Write the data direction of a GPIO bank.
///
/// 1 bits represent outputs, 0 bits represent inputs.
/// </summary>
/// <param name="bank">The name of an available bank</param>
/// <param name="dir">An integer representing data direction bits</param>
public void WriteGPIODir(string bank, uint dir) {
    SoapySDRPINVOKE.Device_WriteGPIODir__SWIG_0(swigCPtr, bank, dir);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
  }

  
/// <summary>
/// Write the data direction of a GPIO bank with a modification mask.
///
/// 1 bits represent outputs, 0 bits represent inputs.
/// </summary>
/// <param name="bank">The name of an available bank</param>
/// <param name="dir">An integer representing data direction bits</param>
/// <param name="mask">A modification mask where 1 = modify</param>
public void WriteGPIODir(string bank, uint dir, uint mask) {
    SoapySDRPINVOKE.Device_WriteGPIODir__SWIG_1(swigCPtr, bank, dir, mask);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
  }

  
/// <summary>
/// Read the data direction of a GPIO bank.
///
/// 1 bits represent outputs, 0 bits represent inputs.
/// </summary>
/// <param name="bank">The name of an available bank</param>
/// <returns>An integer representing data direction bits</returns>
public uint ReadGPIODir(string bank) {
    uint ret = SoapySDRPINVOKE.Device_ReadGPIODir(swigCPtr, bank);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  
/// <summary>
/// Write to an available I2C slave.
///
/// If the device contains multiple I2C masters, the address bits can encode which master.
/// </summary>
/// <param name="addr">The address of the slave</param>
/// <param name="data">An array of bytes to write out</param>
public void WriteI2C(int addr, string data) {
    SoapySDRPINVOKE.Device_WriteI2C(swigCPtr, addr, data);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
  }

  
/// <summary>
/// Read from an available I2C slave.
///
/// If the device contains multiple I2C masters, the address bits can encode which master.
/// </summary>
/// <param name="addr">The address of the slave</param>
/// <param name="numBytes">The number of bytes to read</param>
/// <returns>An array of bytes read from the slave</returns>
public string ReadI2C(int addr, uint numBytes) {
    string ret = SoapySDRPINVOKE.Device_ReadI2C(swigCPtr, addr, numBytes);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  
/// <summary>
/// Perform a SPI transaction and return the result.
///
/// It's up to the implementation to set the clock rate,
/// and read edge, and the write edge of the SPI core.
/// SPI slaves without a readback pin will return 0.
///
/// If the device contains multiple SPI masters,
/// the address bits can encode which master.
/// </summary>
/// <param name="addr">An address of an available SPI slave</param>
/// <param name="data">The SPI data, numBits-1 is first out</param>
/// <param name="numBits">The number of bits to clock out</param>
/// <returns>The readback data, numBits-1 is first in</returns>
public uint TransactSPI(int addr, uint data, uint numBits) {
    uint ret = SoapySDRPINVOKE.Device_TransactSPI(swigCPtr, addr, data, numBits);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  
/// <summary>
/// Write data to a UART device.
///
/// It's up to the implementation to set the baud rate, carriage return settings, flushing on newline.
/// </summary>
/// <param name="which">The name of an available UART</param>
/// <param name="data">An array of bytes to write out</param>
public void WriteUART(string which, string data) {
    SoapySDRPINVOKE.Device_WriteUART(swigCPtr, which, data);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
  }

  
/// <summary>
/// Read bytes from a UART until timeout or newline.
///
/// It's up to the implementation to set the baud rate, carriage return settings, flushing on newline.
/// </summary>
/// <param name="which">The name of an available UART</param>
/// <param name="timeoutUs">Timeout in microseconds</param>
/// <returns>An array of bytes read from the UART</returns>
public string ReadUART(string which, int timeoutUs) {
    string ret = SoapySDRPINVOKE.Device_ReadUART(swigCPtr, which, timeoutUs);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  
/// <summary>
/// A key that uniquely identifies the device driver.
///
/// This key identifies the underlying implementation.
/// Several variants of a product may share a driver.
/// </summary>
public string DriverKey {
    get {
      string ret = SoapySDRPINVOKE.Device_DriverKey_get(swigCPtr);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    } 
  }

  
/// <summary>
/// A key that uniquely identifies the hardware.
///
/// This key should be meaningful to the user
/// to optimize for the underlying hardware.
/// </summary>
public string HardwareKey {
    get {
      string ret = SoapySDRPINVOKE.Device_HardwareKey_get(swigCPtr);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    } 
  }

  
/// <summary>
/// A dictionary of available device information.
///
/// This dictionary can any number of values like
/// vendor name, product name, revisions, serials...
/// This information can be displayed to the user
/// to help identify the instantiated device.
/// </summary>
public Kwargs HardwareInfo {
    get {
      global::System.IntPtr cPtr = SoapySDRPINVOKE.Device_HardwareInfo_get(swigCPtr);
      Kwargs ret = (cPtr == global::System.IntPtr.Zero) ? null : new Kwargs(cPtr, true);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    } 
  }

  
/// <summary>
/// The device's master clock rate in Hz.
/// </summary>
public double MasterClockRate {
    set {
      SoapySDRPINVOKE.Device_MasterClockRate_set(swigCPtr, value);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    } 
    get {
      double ret = SoapySDRPINVOKE.Device_MasterClockRate_get(swigCPtr);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    } 
  }

  
/// <summary>
/// A list of available master clock rates in Hz.
/// </summary>
public RangeList MasterClockRates {
    get {
      global::System.IntPtr cPtr = SoapySDRPINVOKE.Device_MasterClockRates_get(swigCPtr);
      RangeList ret = (cPtr == global::System.IntPtr.Zero) ? null : new RangeList(cPtr, true);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    } 
  }

  
/// <summary>
/// The device's reference clock rate in Hz.
/// </summary>
public double ReferenceClockRate {
    set {
      SoapySDRPINVOKE.Device_ReferenceClockRate_set(swigCPtr, value);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    } 
    get {
      double ret = SoapySDRPINVOKE.Device_ReferenceClockRate_get(swigCPtr);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    } 
  }

  
/// <summary>
/// A list of available reference clock rates in Hz.
/// </summary>
public RangeList ReferenceClockRates {
    get {
      global::System.IntPtr cPtr = SoapySDRPINVOKE.Device_ReferenceClockRates_get(swigCPtr);
      RangeList ret = (cPtr == global::System.IntPtr.Zero) ? null : new RangeList(cPtr, true);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    } 
  }

  
/// <summary>
/// The name of the device's clock source.
/// </summary>
public string ClockSource {
    set {
      SoapySDRPINVOKE.Device_ClockSource_set(swigCPtr, value);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    } 
    get {
      string ret = SoapySDRPINVOKE.Device_ClockSource_get(swigCPtr);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    } 
  }

  
/// <summary>
/// A list of the device's available clock sources.
/// </summary>
public StringList ClockSources {
    get {
      global::System.IntPtr cPtr = SoapySDRPINVOKE.Device_ClockSources_get(swigCPtr);
      StringList ret = (cPtr == global::System.IntPtr.Zero) ? null : new StringList(cPtr, true);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    } 
  }

  
/// <summary>
/// The name of the device's time source.
/// </summary>
public string TimeSource {
    set {
      SoapySDRPINVOKE.Device_TimeSource_set(swigCPtr, value);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    } 
    get {
      string ret = SoapySDRPINVOKE.Device_TimeSource_get(swigCPtr);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    } 
  }

  
/// <summary>
/// A list of the device's available time sources.
/// </summary>
public StringList TimeSources {
    get {
      global::System.IntPtr cPtr = SoapySDRPINVOKE.Device_TimeSources_get(swigCPtr);
      StringList ret = (cPtr == global::System.IntPtr.Zero) ? null : new StringList(cPtr, true);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    } 
  }

  
/// <summary>
/// A list of the device's available register interfaces by name.
/// </summary>
public StringList RegisterInterfaces {
    get {
      global::System.IntPtr cPtr = SoapySDRPINVOKE.Device_RegisterInterfaces_get(swigCPtr);
      StringList ret = (cPtr == global::System.IntPtr.Zero) ? null : new StringList(cPtr, true);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    } 
  }

  
/// <summary>
/// A list of the device's available GPIO banks by name.
/// </summary>
public StringList GPIOBanks {
    get {
      global::System.IntPtr cPtr = SoapySDRPINVOKE.Device_GPIOBanks_get(swigCPtr);
      StringList ret = (cPtr == global::System.IntPtr.Zero) ? null : new StringList(cPtr, true);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    } 
  }

  
/// <summary>
/// A list of the device's available UART devices by name.
/// </summary>
public StringList UARTs {
    get {
      global::System.IntPtr cPtr = SoapySDRPINVOKE.Device_UARTs_get(swigCPtr);
      StringList ret = (cPtr == global::System.IntPtr.Zero) ? null : new StringList(cPtr, true);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    } 
  }

  
/// <summary>
/// Create a device instance from the first device SoapySDR finds.
/// </summary>
public Device() : this(SoapySDRPINVOKE.new_Device__SWIG_0(), true) {
    
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    BuildInfo.ValidateABI();
}
  static private global::System.IntPtr SwigConstructDevice(System.Collections.Generic.IDictionary<string, string> kwargs) {

        Kwargs tempkwargs = Utility.ToKwargs(kwargs);
    
    return SoapySDRPINVOKE.new_Device__SWIG_1(Kwargs.getCPtr(tempkwargs));
  }

  
/// <summary>
/// Create a device instance based on the given construction args.
/// </summary>
/// <param name="args">Device construction args</param>
public Device(System.Collections.Generic.IDictionary<string, string> kwargs) : this(Device.SwigConstructDevice(kwargs), true) {
    
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    BuildInfo.ValidateABI();
}
  
/// <summary>
/// Create a device instance based on the given construction args.
/// </summary>
/// <param name="args">Device construction args</param>
public Device(string args) : this(SoapySDRPINVOKE.new_Device__SWIG_2(args), true) {
    
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    BuildInfo.ValidateABI();
}
  internal StreamHandle SetupStreamInternal(Direction direction, string format, UnsignedListInternal channels, System.Collections.Generic.IDictionary<string, string> kwargs) {

        var tempchannels = new UnsignedListInternal(channels);
    

        Kwargs tempkwargs = Utility.ToKwargs(kwargs);
    
    {
      StreamHandle ret = new StreamHandle(SoapySDRPINVOKE.Device_SetupStreamInternal(swigCPtr, (int)direction, format, UnsignedListInternal.getCPtr(tempchannels), Kwargs.getCPtr(tempkwargs)), true);
      if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
      return ret;
    }
  }

  internal void CloseStreamInternal(StreamHandle streamHandle) {
    SoapySDRPINVOKE.Device_CloseStreamInternal(swigCPtr, StreamHandle.getCPtr(streamHandle));
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
  }

  internal uint GetStreamMTUInternal(StreamHandle streamHandle) {
    uint ret = SoapySDRPINVOKE.Device_GetStreamMTUInternal(swigCPtr, StreamHandle.getCPtr(streamHandle));
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  internal ErrorCode ActivateStreamInternal(StreamHandle streamHandle, StreamFlags flags, long timeNs, uint numElems) {
    ErrorCode ret = (ErrorCode)SoapySDRPINVOKE.Device_ActivateStreamInternal(swigCPtr, StreamHandle.getCPtr(streamHandle), (int)flags, timeNs, numElems);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  internal ErrorCode DeactivateStreamInternal(StreamHandle streamHandle, StreamFlags flags, long timeNs) {
    ErrorCode ret = (ErrorCode)SoapySDRPINVOKE.Device_DeactivateStreamInternal(swigCPtr, StreamHandle.getCPtr(streamHandle), (int)flags, timeNs);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  internal StreamResultPairInternal ReadStreamInternal(StreamHandle streamHandle, PointerListInternal buffs, uint numElems, int timeoutUs) {
    StreamResultPairInternal ret = new StreamResultPairInternal(SoapySDRPINVOKE.Device_ReadStreamInternal(swigCPtr, StreamHandle.getCPtr(streamHandle), PointerListInternal.getCPtr(buffs), numElems, timeoutUs), true);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  internal StreamResultPairInternal WriteStreamInternal(StreamHandle streamHandle, PointerListInternal buffs, uint numElems, StreamFlags flags, long timeNs, int timeoutUs) {
    StreamResultPairInternal ret = new StreamResultPairInternal(SoapySDRPINVOKE.Device_WriteStreamInternal(swigCPtr, StreamHandle.getCPtr(streamHandle), PointerListInternal.getCPtr(buffs), numElems, (int)flags, timeNs, timeoutUs), true);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

  internal StreamResultPairInternal ReadStreamStatusInternal(StreamHandle streamHandle, int timeoutUs) {
    StreamResultPairInternal ret = new StreamResultPairInternal(SoapySDRPINVOKE.Device_ReadStreamStatusInternal(swigCPtr, StreamHandle.getCPtr(streamHandle), timeoutUs), true);
    if (SoapySDRPINVOKE.SWIGPendingException.Pending) throw SoapySDRPINVOKE.SWIGPendingException.Retrieve();
    return ret;
  }

    public string GetNativeStreamFormat(Direction rx, uint channelNo, out object nativeStreamFullSale)
    {
      throw new NotImplementedException();
    }
  }

}
